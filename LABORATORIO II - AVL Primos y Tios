#include <SFML/Graphics.hpp>
#include <iostream>
#include <vector>

using namespace std;

template <class T>
struct Node {
    Node* left, * right;
    T val;

    Node(T v) : left(nullptr), right(nullptr), val(v) {}
};

template <class T>
struct AVL {
    Node<T>* root;
    vector<Node<T>*> camino;

    AVL() : root(nullptr) {}

    bool find(T value, Node<T>*& position) {
        position = root;
        camino.clear();
        while (position) {
            camino.push_back(position);
            if (position->val > value) {
                position = position->left;
            }
            else if (position->val < value) {
                position = position->right;
            }
            else {
                return true;
            }
        }
        return false;
    }

    int height(Node<T>* p) {
        if (!p) return 0;
        return 1 + max(height(p->left), height(p->right));
    }

    void leftRotate(Node<T>*& x) {
        Node<T>* y = x->right;
        x->right = y->left;
        y->left = x;
        x = y;
    }

    void rightRotate(Node<T>*& y) {
        Node<T>* x = y->left;
        y->left = x->right;
        x->right = y;
        y = x;
    }

    void Balance() {
        for (int i = camino.size() - 1; i >= 0; i--) {
            int diff = height(camino[i]->right) - height(camino[i]->left);
            if (diff == 2) {
                if (height(camino[i]->right->left) > height(camino[i]->right->right)) {
                    rightRotate(camino[i]->right);
                }
                leftRotate(camino[i]);
            }
            else if (diff == -2) {
                if (height(camino[i]->left->right) > height(camino[i]->left->left)) {
                    leftRotate(camino[i]->left);
                }
                rightRotate(camino[i]);
            }
            if (i == 0) {
                root = camino[i];
            }
            else {
                Node<T>* parent = camino[i - 1];
                if (parent->left == camino[i]) {
                    parent->left = camino[i];
                }
                else {
                    parent->right = camino[i];
                }
            }
        }
    }

    void add(T v) {
        Node<T>* puntero;
        if (!root) {
            root = new Node<T>(v);
            return;
        }
        if (!find(v, puntero)) {
            Node<T>* newNode = new Node<T>(v);
            Node<T>* parent = camino.back();
            if (parent->val > v) parent->left = newNode;
            else parent->right = newNode;
            camino.push_back(newNode);
            Balance();
        }
        else {
            cout << "Este valor ya existe en el arbol" << endl;
        }
    }

    void remove(T value) {
        Node<T>* target;
        if (!find(value, target)) {
            cout << "El valor no existe en el árbol." << endl;
            return;
        }

        if (target == root) {
            if (!root->left && !root->right) {
                delete root;
                root = nullptr;
            }
            else if (!root->left || !root->right) {
                Node<T>* newRoot = root->left ? root->left : root->right;
                delete root;
                root = newRoot;
            }
            else {
                eliminarNodoConDosHijos(root);
            }
            camino.erase(std::remove(camino.begin(), camino.end(), target), camino.end());
            Balance();
            return;
        }

        if (!target->left && !target->right) {
            eliminarHoja(target);
        }
        else if (!target->left || !target->right) {
            eliminarNodoConHijo(target);
        }
        else {
            eliminarNodoConDosHijos(target);
        }

        camino.erase(std::remove(camino.begin(), camino.end(), target), camino.end());
        Balance();
    }

    void eliminarHoja(Node<T>* target) {
        if (camino.size() < 2) return;

        Node<T>* parent = camino[camino.size() - 2];
        if (parent->left == target) {
            parent->left = nullptr;
        }
        else if (parent->right == target) {
            parent->right = nullptr;
        }

        camino.erase(std::remove(camino.begin(), camino.end(), target), camino.end());
        delete target;
    }

    void eliminarNodoConHijo(Node<T>* target) {
        if (camino.size() < 2) return;

        Node<T>* parent = camino[camino.size() - 2];
        Node<T>* child = target->left ? target->left : target->right;

        if (parent->left == target) {
            parent->left = child;
        }
        else if (parent->right == target) {
            parent->right = child;
        }

        camino.erase(std::remove(camino.begin(), camino.end(), target), camino.end());
        delete target;
    }

    void eliminarNodoConDosHijos(Node<T>* target) {
        Node<T>* successorParent = target;
        Node<T>* successor = target->right;

        while (successor->left) {
            successorParent = successor;
            successor = successor->left;
        }

        target->val = successor->val;

        if (successorParent->left == successor) {
            successorParent->left = successor->right;
        }
        else {
            successorParent->right = successor->right;
        }

        camino.erase(std::remove(camino.begin(), camino.end(), successor), camino.end());
        delete successor;
    }

    void findTios(Node<T>* root, T value, vector<Node<T>*>& tios) {
        Node<T>* puntero;
        if (!find(value, puntero)) return;

        if (camino.size() < 2) return;
        Node<T>* parent = camino[camino.size() - 2];

        if (camino.size() > 2) {
            Node<T>* grandparent = camino[camino.size() - 3];
            if (grandparent->left == parent && grandparent->right) {
                tios.push_back(grandparent->right);
            }
            else if (grandparent->right == parent && grandparent->left) {
                tios.push_back(grandparent->left);
            }
        }
    }

    void Primos_Tios(T v, vector<Node<T>*>& primos, vector<Node<T>*>& tios) {
        tios.clear();
        primos.clear();
        findTios(root, v, tios);

        for (auto tio : tios) {
            if (tio->left) primos.push_back(tio->left);
            if (tio->right) primos.push_back(tio->right);
        }

        cout << "Tios: ";
        for (auto& tio : tios) {
            cout << tio->val << " ";
        }
        cout << endl;

        cout << "Primos: ";
        for (auto& primo : primos) {
            cout << primo->val << " ";
        }
        cout << endl;
    }

    void print(Node<T>* n) {
        if (!n) return;
        print(n->left);
        cout << n->val << ": ";
        if (n->left) cout << n->left->val << " ";
        if (n->right) cout << n->right->val;
        cout << endl;
        print(n->right);
    }

    void print() {
        print(root);
    }
};

template <class T>
void drawTree(sf::RenderWindow& window, Node<T>* node, float x, float y, float xOffset, float level, const sf::Font& font, const vector<Node<T>*>& primos, const vector<Node<T>*>& tios) {
    if (!node) return;

    sf::CircleShape circle(20.f);

    if (find(primos.begin(), primos.end(), node) != primos.end()) {
        circle.setFillColor(sf::Color::Blue);
    }
    else if (find(tios.begin(), tios.end(), node) != tios.end()) {
        circle.setFillColor(sf::Color::Green);
    }
    else {
        circle.setFillColor(sf::Color::Black);
    }

    circle.setPosition(x, y);
    window.draw(circle);

    sf::Text text(to_string(node->val), font, 20);
    text.setPosition(x + 8, y + 5);
    window.draw(text);

    if (node->left) {
        sf::Vertex line[] = {
            sf::Vertex(sf::Vector2f(x + 20, y + 20), sf::Color::Black),
            sf::Vertex(sf::Vector2f(x - xOffset + 20, y + 80), sf::Color::Black)
        };
        window.draw(line, 2, sf::Lines);
        drawTree(window, node->left, x - xOffset, y + 80, xOffset / 2, level + 1, font, primos, tios);
    }

    if (node->right) {
        sf::Vertex line[] = {
            sf::Vertex(sf::Vector2f(x + 20, y + 20), sf::Color::Black),
            sf::Vertex(sf::Vector2f(x + xOffset + 20, y + 80), sf::Color::Black)
        };
        window.draw(line, 2, sf::Lines);
        drawTree(window, node->right, x + xOffset, y + 80, xOffset / 2, level + 1, font, primos, tios);
    }
}

int main() {
    AVL<int> arbol;

    sf::Font font;
    if (!font.loadFromFile("C:/Users/Usuario/Downloads/Arial.ttf")) {
        cerr << "Failed to load font." << endl;
        return 1;
    }

    sf::RenderWindow window(sf::VideoMode(1280, 720), "AVL Tree");

    vector<Node<int>*> primos, tios;

    while (window.isOpen()) {
        sf::Event event;
        while (window.pollEvent(event)) {
            if (event.type == sf::Event::Closed)
                window.close();

            if (event.type == sf::Event::KeyPressed) {
                if (event.key.code == sf::Keyboard::A) {
                    int value;
                    cout << "Enter value to add: ";
                    cin >> value;
                    arbol.add(value);
                }
                if (event.key.code == sf::Keyboard::R) {
                    int value;
                    cout << "Enter value to remove: ";
                    cin >> value;
                    arbol.remove(value);
                }
                if (event.key.code == sf::Keyboard::P) {
                    int value;
                    cout << "Enter value to see cousins ​​and uncles: ";
                    cin >> value;
                    primos.clear();
                    tios.clear();
                    arbol.Primos_Tios(value, primos, tios);
                }
            }
        }

        window.clear(sf::Color::White);

        if (arbol.root) {
            drawTree(window, arbol.root, 640, 50, 300, 1, font, primos, tios);
        }

        window.display();
    }
}